
## Final Project

###  LLM Use Disclaimer

I used an LLM tool (ChatGPT, GPT-5.1) during the development of this project.  <br>
The LLM was used for the following purposes:  <br>
Clarifying how to use Arduino libraries, specifically the MPU-6050 sensor library and the LiquidCrystal_I2C LCD library.  <br>
Troubleshooting coding issues, including sensor readings, LCD setup, and general Arduino workflow.  <br>
Improving grammar of written content used in my project.  <br>
The LLM was not used to generate complete design the project. 
All hardware work, wiring, coding logic, interaction design, and prototype implementation were completed by myself.  The LLM served only as a writing and technical reference tool.<br>
LLM Used: ChatGPT (GPT-5.1) 

Transcript Link: <br>
I2C backpack: https://chatgpt.com/share/692fb2a7-a75c-8013-b2c2-fd50659a4d65<br>
Troubleshooting for LCD not displaying: https://chatgpt.com/share/692fb32e-e144-8013-886b-342b46455bb0<br>
Troubleshooting for MPU6050: https://chatgpt.com/share/692fb378-e288-8013-bd3f-101a17a31cf4<br>
Inquiry about 12C wiring: https://chatgpt.com/share/692fb399-af44-8013-8e91-0819ec2aacd1<br>
LiquidCrystal I2C Code Library: https://chatgpt.com/share/692fb3d3-faec-8013-8b57-7e00ade21753<br>
About 3D printing modeling: https://chatgpt.com/share/692fb404-956c-8013-add3-9cb92d0e5488<br>

###  Project Description
![1 1 1_画板 1](https://git.arts.ac.uk/user-attachments/assets/80f3042c-43e7-499d-9dbf-6de21bb7aab5)

Key words: Wearable Interactive Device; Speculative Design; Embodied Interaction; Sensor-Driven<br>
“Time Will Break If I Stop” is a wearable interactive device that explores how my bodily rhythm determines the stability of time. The project stems from a personal feeling that time does not naturally flow—it must be sustained by my tapping and attention. When the rhythm is steady, time appears ordered; when it falters, time becomes messy and unpredictable; when I stop, time “breaks” with a harsh sound. By capturing subtle movements of the finger, the device translates my physical state into shifting temporal conditions. It becomes both a technical object and a metaphor, reflecting anxiety, control, and the fragile dependency between my body and the passage of time.<br>

###  Demo Video
https://git.arts.ac.uk/user-attachments/assets/c6ba855a-e07f-414a-b261-c39327027030

###  Images of Final Prototype
![12 2 ARDUINO 时间穿戴 展示图Hhhjpg_画板 1 副本 2](https://git.arts.ac.uk/user-attachments/assets/e8663a85-7749-4167-b888-49fd9c685322)

![9be66af6cbf29df6d4469daf32931d26](https://git.arts.ac.uk/user-attachments/assets/d78840d8-fbd9-4228-abf2-3439c5dab302)









###  All Code Files


```cpp


#include <Wire.h>
#include <LiquidCrystal_I2C.h>

//Import the code library

LiquidCrystal_I2C lcd(0x27, 16, 2);

const int MPU_ADDR   = 0x68;   // MPU6050 / MPU9250 I2C 
const int buzzerPin  = 9;      // pin

// Knocking
unsigned long lastTapTime = 0;
unsigned long lastTapIntervals[5]; 
int tapIntervalCount = 0;
// tap ---200ms---> tap ---210ms---> tap ——195ms——> tap

// Lower the sensitivity
const int16_t TAP_THRESHOLD         = 9000;  
const unsigned long TAP_DEBOUNCE    = 300;   
const unsigned long NO_TAP_TIMEOUT  = 2000;  

// Three states
enum RhythmState {
  STATE_NO_TAP,
  STATE_REGULAR,
  STATE_IRREGULAR
};

RhythmState currentState = STATE_NO_TAP;
RhythmState lastState    = STATE_NO_TAP;

// millis simulated time
unsigned long timeBaseMs      = 0;  
unsigned long lastTimeUpdate  = 0;  

// initialize MPU
void initMPU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);   
  Wire.write(0);      
  Wire.endTransmission(true);
}

// Read the acceleration
long readAccelMagnitude2() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);  
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  int16_t ax = (Wire.read() << 8) | Wire.read();
  int16_t ay = (Wire.read() << 8) | Wire.read();
  int16_t az = (Wire.read() << 8) | Wire.read();

  long mag2 = (long)ax * ax + (long)ay * ay + (long)az * az;
  return mag2;
   // This piece of code was generated by GPT with my assistance

}

// Core logic: Read the current acceleration modulus and compare it with the previous one. If the change is greater than the threshold → determine it as a strike
// This piece of code was generated and refined by me with the help of ChatGPT after designing the logic, and is used to implement specific functions.
bool detectTap() {
  static long lastMag2  = 0;
  static bool firstRead = true;

  long mag2 = readAccelMagnitude2();

  if (firstRead) {
    lastMag2  = mag2;
    firstRead = false;
    return false;
  }

  long diff = labs(mag2 - lastMag2);
  lastMag2  = mag2;

  unsigned long now = millis();

  if (diff > (long)TAP_THRESHOLD * (long)TAP_THRESHOLD &&
      (now - lastTapTime) > TAP_DEBOUNCE) {

    if (lastTapTime != 0) {
      unsigned long interval = now - lastTapTime;

      if (tapIntervalCount < 5) {
        lastTapIntervals[tapIntervalCount] = interval;
        tapIntervalCount++;
      } else {
        
        for (int i = 0; i < 4; i++) {
          lastTapIntervals[i] = lastTapIntervals[i + 1];
        }
        lastTapIntervals[4] = interval;
      }
    }
    lastTapTime = now;
    Serial.println("Tap detected");
    return true;
  }

  return false;
}

// This piece of code was generated and refined by me with the help of ChatGPT after designing the logic, and is used to implement specific functions.
// I have learned that it is achieved by comparing historical data in an array.
RhythmState computeState() {
  unsigned long now = millis();

  // haven't tapped for a long time, so I'll go back to NO TAP and clear the historical taps
  if (lastTapTime == 0 || (now - lastTapTime) > NO_TAP_TIMEOUT) {
    tapIntervalCount = 0;   
    return STATE_NO_TAP;
  }

  // Insufficient tapping times: Before a rhythm is formed, just treat it as "NO TAP" instead of "IRREGULAR"
  if (tapIntervalCount < 3) {
    return STATE_NO_TAP;
  }

  // The interval between the last three strikes
  unsigned long i1 = lastTapIntervals[tapIntervalCount - 1];
  unsigned long i2 = lastTapIntervals[tapIntervalCount - 2];
  unsigned long i3 = lastTapIntervals[tapIntervalCount - 3];

  // equispaced
  float mean = (i1 + i2 + i3) / 3.0;

  // The magnitude by which each interval deviates from the average value
  // This piece of code was generated by GPT with my assistance

  float dev1 = abs((float)i1 - mean);
  float dev2 = abs((float)i2 - mean);
  float dev3 = abs((float)i3 - mean);

  // Lenient rules
  float threshold = mean * 0.4;

  if (dev1 < threshold && dev2 < threshold && dev3 < threshold) {
    return STATE_REGULAR;
  } else {
    return STATE_IRREGULAR;
  }
}

// Update LCD
void updateLCD(RhythmState state) {
  unsigned long now = millis();

  // -------- REGULAR：TIME --------
  if (state == STATE_REGULAR) {
    // time display
    if (now - lastTimeUpdate >= 1000) {
      lastTimeUpdate = now;

      unsigned long totalSec = (now - timeBaseMs) / 1000;
      unsigned int hours   = (totalSec / 3600) % 24;
      unsigned int minutes = (totalSec / 60)   % 60;
      unsigned int seconds = totalSec % 60; // This piece of code was generated by GPT with my assistance

      char line[17];
      sprintf(line, "%02u:%02u:%02u", hours, minutes, seconds);

      // the first line
      lcd.setCursor(0, 0);
      lcd.print("                ");   

      // the second line
      lcd.setCursor(4, 1);  
      lcd.print(line);
      lcd.print("   ");      
    }
  }// This piece of code was generated by GPT with my assistance


  // IRREGULAR 
  else if (state == STATE_IRREGULAR) {
    lcd.setCursor(0, 0);
    char buf1[17];
    for (int i = 0; i < 16; i++) {
      // mmediately, garbled characters were generated
      buf1[i] = (char)random(176, 223);
    }
    buf1[16] = '\0';
    lcd.print(buf1);

    lcd.setCursor(0, 1);
    char buf2[17];
    for (int i = 0; i < 16; i++) {
      buf2[i] = (char)random(176, 223);
    }
    buf2[16] = '\0';
    lcd.print(buf2);
  }
  // NO_TAP：TIME BROKEN 
  else {  // STATE_NO_TAP
    lcd.setCursor(0, 0);
    lcd.print("  TIME BROKEN   ");
    lcd.setCursor(0, 1);
    lcd.print("!!!!!!!!!!!!!!!!");
  }
}

// Buzzer control
void updateBuzzer(RhythmState state) {
  unsigned long now = millis();

  if (state == STATE_NO_TAP) {
    // Continuous warning sound
    tone(buzzerPin, 400);
    return;
  }

  if (state == STATE_REGULAR) {
    unsigned long period = 300;
    unsigned long onTime = 120;

    unsigned long phase = now % period;
    if (phase < onTime) {
      tone(buzzerPin, 800);
    } else {
      noTone(buzzerPin);
    }
    return;
  }

  if (state == STATE_IRREGULAR) {
  // Chaotic sound
    static unsigned long nextChange = 0;
    static bool weirdOn    = false;
    static int currentFreq = 600;

    if (now >= nextChange) {
      weirdOn = !weirdOn;

      if (weirdOn) {
        currentFreq = random(500, 2000);
        tone(buzzerPin, currentFreq);
        nextChange = now + random(60, 200);
      } else {
        noTone(buzzerPin);
        nextChange = now + random(40, 160);
      }
    }
    return;
  }
}

// initialize

void setup() {
  Wire.begin();
  Serial.begin(115200);

  pinMode(buzzerPin, OUTPUT);
  noTone(buzzerPin);

  randomSeed(analogRead(A0));

  initMPU();

  lcd.init();
  lcd.backlight();

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("System Ready");
  delay(800);
  lcd.clear();

  timeBaseMs     = millis();  // Start counting "time"
  lastTimeUpdate = millis();

  lastState = STATE_NO_TAP;
  updateLCD(lastState);
}

void loop() {
  detectTap();
  currentState = computeState();

  // Clear the screen when the status changes
  if (currentState != lastState) {
    lcd.clear();
    lastState = currentState;
  }

  updateLCD(currentState);
  updateBuzzer(currentState);

  delay(10);
}


```


###  Background Research & Inspiration
![12 2 ARDUINO 时间穿戴文献真正的最终版_画板 1 副本](https://git.arts.ac.uk/user-attachments/assets/8eb671d1-6286-4977-a03d-cfcbbf4b8d50)
![12 2 ARDUINO 时间穿戴参考图最终最终_画板 1 副本 4](https://git.arts.ac.uk/user-attachments/assets/5e45d668-f48b-4c7e-83f8-a2afeb7b161f)


"Inspiration"<br>
The project originates from a recurring emotional state where time becomes fragile whenever I face pressure, deadlines, or expectations. Instead of flowing naturally, time feels like something I must physically sustain. The moment my attention drifts or my rhythm falters, time seems to lose its structure—jumping, stuttering, or collapsing entirely.This personal sensation of “having to push time forward” becomes the conceptual foundation of the work.<br>
"Time as a Subjective and Unstable Experience"<br>
Philosophers such as Henri Bergson propose that time is not an external measurement but a lived psychological duration. Media theory further suggests that attention and emotion actively shape temporal experience, meaning that time can accelerate, stall, or collapse depending on stress and internal rhythm.This diagram shows how stress occurs when external demands exceed one’s perceived ability to cope. The imbalance leads to either successful coping or stress symptoms. It supports the idea that emotional pressure disrupts internal rhythm—making time feel unstable.<br>
"Stress-Induced Distortions of Time Perception"<br>
Distortions of duration perception are often observed in response to highly arousing stimuli. In our study, after a stress-inducing task (Paced Auditory Serial Addition Test, PASAT), participants showed altered time perception compared to controls — demonstrating that psychophysiological stress may alter subsequent perception of time. <br>
Source of diagram: Psychophysiological stress influences temporal accuracy (Cellini et al., 2023), PMC. <br>
https://pmc.ncbi.nlm.nih.gov/articles/PMC10471659/ <br>
"Micro-Movements and Anxiety: Understanding Fidgeting" <br>
AnxietyCentre describes fidgeting, restlessness, and repetitive micro-movements (e.g. finger tapping, leg bouncing, shifting in seat) as common physical responses to anxiety and stress. These involuntary gestures are often unconscious, and arise when the nervous system is over-aroused — providing a sort of “release valve” for inner tension and nervous energy. <br>
[https://www.anxietycentre.com/anxiety-disorders/symptoms/fidgeting/![image](https://git.arts.ac.uk/user-attachments/assets/fac7dc12-e08b-4627-bd1f-f19eeb53a53f)](https://www.anxietycentre.com/anxiety-disorders/symptoms/fidgeting/) <br>
"Time Perception" <br>
Time is not fixed; it is shaped by emotion, attention, and bodily rhythm.<br>
http://plato.stanford.edu/entries/consciousness-temporal/<br>
"Stress & Time Distortion" <br>
https://pmc.ncbi.nlm.nih.gov/articles/PMC10471659/?utm_source=chatgpt.com <br>
"Attention Rhythm"<br>
https://www.anxietycentre.com/anxiety-disorders/symptoms/fidgeting/?utm_source=chatgpt.com <br>
https://www.verywellhealth.com/why-am-i-fidgeting-5211372?utm_source=chatgpt.com<br>
"Reference works"<br>
《you, me and all these machines》https://vtol.cc/filter/works/you-me-and-all-these-machines <br>
《last breath》https://vtol.cc/filter/works/last-breath <br>

###  Sketches, Diagrams, and Design Documents
![12 2 ARDUINO 时间穿戴第四页_画板 1 副本 3](https://git.arts.ac.uk/user-attachments/assets/2b3730d9-3acf-45ce-9ac1-245d59c55b68)

testing videos:

https://git.arts.ac.uk/user-attachments/assets/3cbdba3a-330a-4b46-b2dc-e2dbc1430ba5





###  REFLECTING
Throughout this project, I learned the importance of leaving enough time for adjustments and troubleshooting. Many issues that seemed minor during early prototyping became significant once the device was worn on the body. Because wearable devices constantly move, bend, and pull with the user, loose solder joints and unstable wiring caused frequent interruptions, reminding me that wearables require far greater structural stability than stationary prototypes.


I also realised that the physical form of a wearable is just as important as its technical function. Since the device sits directly on the body, its shape, material, scale, and attachment method strongly influence comfort and usability. A wearable without a coherent or intentional form can feel improvised, even if the interaction works. At the same time, the aesthetics and unique identity of the outer shell are crucial for communicating the project’s concept—especially one centred on the idea that “time is maintained by the body.”
In future iterations, I would prioritise stronger soldering, better cable management, and more thoughtful enclosure and form design, ensuring the device is both reliable in use and visually meaningful when worn.

###  ITERATION CODE

First: Only two states: time display / time broken

```cpp


#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);
const int buzzerPin = 9;
const int MPU_ADDR  = 0x68;

unsigned long lastTap = 0;

void initMPU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
}

bool detectTap() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  int16_t ax = (Wire.read() << 8) | Wire.read();
  long mag = abs(ax);

  if (mag > 20000) {
    return true;
  }
  return false;
}

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  pinMode(buzzerPin, OUTPUT);
  initMPU();
}

void loop() {
  if (detectTap()) {
    lastTap = millis();
  }

  unsigned long now = millis();

  if (now - lastTap < 2000) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("TIME OK");
    noTone(buzzerPin);
  } else {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("TIME BROKEN");
    tone(buzzerPin, 500);
  }

  delay(150);
}

```

Second: Introduced a third state, comparing whether the intervals are similar

```cpp


#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

const int buzzerPin = 9;
const int MPU_ADDR  = 0x68;

unsigned long lastTap = 0;
unsigned long prevInterval = 0;
unsigned long lastInterval = 0;

enum State { NO_TAP, REGULAR, IRREGULAR };
State state = NO_TAP;

void initMPU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
}

bool detectTap() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  int16_t ax = (Wire.read() << 8) | Wire.read();
  long mag = abs(ax);
  return (mag > 20000);
}

void updateState() {
  unsigned long now = millis();

  if (detectTap()) {
    unsigned long interval = now - lastTap;
    prevInterval = lastInterval;
    lastInterval = interval;
    lastTap = now;

    if (prevInterval == 0) {
      state = NO_TAP;
    } else if (abs((long)prevInterval - (long)lastInterval) < 150) {
      state = REGULAR;
    } else {
      state = IRREGULAR;
    }
    return;
  }

  if (now - lastTap > 2000) {
    state = NO_TAP;
  }
}

void updateLCD() {
  lcd.clear();
  if (state == REGULAR) {
    lcd.print("REGULAR");
  } else if (state == IRREGULAR) {
    lcd.print("IRREGULAR");
  } else {
    lcd.print("TIME BROKEN");
  }
}

void updateBuzzer() {
  if (state == REGULAR) {
    tone(buzzerPin, 800, 120);
  } else if (state == IRREGULAR) {
    tone(buzzerPin, random(400, 1200), 80);
  } else {
    tone(buzzerPin, 400);
  }
}

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  pinMode(buzzerPin, OUTPUT);
  initMPU();
}

void loop() {
  updateState();
  updateLCD();
  updateBuzzer();
  delay(120);
}



```
Third:

```cpp


#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

const int MPU_ADDR   = 0x68;
const int buzzerPin  = 9;

unsigned long tapTimes[6];
int tapCount = 0;

enum Mode { BROKEN, STABLE, CHAOTIC };
Mode mode = BROKEN;

void resetTaps() {
  tapCount = 0;
  for (int i = 0; i < 6; i++) tapTimes[i] = 0;
}

void initMPU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
}

bool detectTap() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  int16_t ax = (Wire.read() << 8) | Wire.read();
  long magnitude = abs(ax);

  return (magnitude > 25000);
}

void updateMode() {
  unsigned long now = millis();

  if (detectTap()) {
    tapTimes[tapCount % 6] = now;
    tapCount++;

    if (tapCount > 3) {
      unsigned long i1 = tapTimes[(tapCount - 1) % 6] - tapTimes[(tapCount - 2) % 6];
      unsigned long i2 = tapTimes[(tapCount - 2) % 6] - tapTimes[(tapCount - 3) % 6];
      unsigned long diff = abs((long)i1 - (long)i2);

      if (diff < 150) mode = STABLE;
      else mode = CHAOTIC;
    }
    return;
  }

  if (tapCount == 0 || now - tapTimes[(tapCount - 1) % 6] > 1800) {
    mode = BROKEN;
    resetTaps();
  }
}

void updateLCD() {
  lcd.clear();

  if (mode == STABLE) {
    lcd.print("TIME STABLE");
  } else if (mode == CHAOTIC) {
    char c[17];
    for (int i = 0; i < 16; i++) c[i] = random(160, 240);
    c[16] = '\0';
    lcd.print(c);
  } else {
    lcd.print("TIME BROKEN");
  }
}

void updateBuzzer() {
  if (mode == STABLE) {
    tone(buzzerPin, 850, 120);
  } else if (mode == CHAOTIC) {
    tone(buzzerPin, random(300, 2000), 100);
  } else {
    tone(buzzerPin, 400);
  }
}

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  pinMode(buzzerPin, OUTPUT);
  initMPU();
}

void loop() {
  updateMode();
  updateLCD();
  updateBuzzer();
  delay(100);
}



```

###  OTHERS

![12 2 ARDUINO 时间穿戴 其他照片-06](https://git.arts.ac.uk/user-attachments/assets/0588c566-e273-4da7-8755-cf7c82302de2)


https://git.arts.ac.uk/user-attachments/assets/8d48b0a0-ff65-45da-a9e5-f45eaae4cac2


